/**
 * @class StatisticOperations
 * @description The "StatisticOperations" class provides various methods for calculating
 * statistical operations such as `count`, `sum`, `min`, `max`, `mean`, `median`, `mode`, `variance`,
 * and `standard deviation` on numerical data.
 */
export class StatisticOperations {
  constructor() {}

  /**
   * The function `onlyNumberColumnFilter` filters out columns from an array that have a data type of
   * "number".
   * @param dataType - The `dataType` parameter is an object that represents the data type of each
   * column in the "DataFrame". It is a key-value pair where the key is the column name and the value is the
   * data type of that column.
   * @param {string[]} columns - An array of column names.
   * @returns an array of eligible columns that have a numeric data type.
   */
  onlyNumberColumnFilter(
    dataType: Record<string, string>,
    columns: string[]
  ): string[] {
    if (
      !dataType ||
      !Object.keys(dataType).length ||
      !columns ||
      !columns.length
    ) {
      return [];
    }
    let eligibleColumns: string[] = [];
    columns.forEach((column) => {
      if (dataType[column] === "number") {
        eligibleColumns.push(column);
      }
    });
    return eligibleColumns;
  }

  // Return the count.
  /**
   * The count function returns the length of an array, or NaN if it is empty or undefined.
   * @param {any[]} data - The parameter "data" is an array of any type of data.
   * @returns The length of the input array `data` is being returned.
   */
  count(data: any[]): number {
    if (!data || !data.length) return NaN;
    return data.length;
  }

  // Calculate the sum.
  // AI Generated Code
  /**
   * The function "sum" takes an array of numbers as input and returns the sum of all the numbers in it.
   * @param {number[]} data - The parameter "data" is an array of numbers.
   * @returns the sum of all the numbers in the `data` array.
   */
  sum(data: number[]): number {
    if (!data || !data.length) return NaN;
    return data.reduce((sum, value) => sum + value, 0);
  }

  // Calculate the min.
  // AI Generated Code
  /**
   * The `min` function takes an array of numbers and returns the smallest number in the array.
   * @param {number[]} data - An array of numbers
   * @returns The minimum value from the given array of numbers is being returned.
   */
  min(data: number[]): number {
    if (!data || !data.length) return NaN;
    return data.reduce((min, value) => (min < value ? min : value), Infinity);
  }

  // Calculate the max.
  // AI Generated Code
  /**
   * The function "max" takes an array of numbers as input and returns the maximum value in the array.
   * @param {number[]} data - The parameter "data" is an array of numbers.
   * @returns the maximum value from the given array of numbers.
   */
  max(data: number[]): number {
    if (!data || !data.length) return NaN;
    return data.reduce((max, value) => (max > value ? max : value), -Infinity);
  }

  // Partially Generated By AI
  // Added corner case Handling
  /**
   * The mean function calculates the average of an array of numbers.
   * @param {number[]} data - The "data" parameter is an array of numbers.
   * @returns The mean of the given data array.
   */
  mean(data: number[]): number {
    let sum = 0;
    if (!data || !data.length) return NaN;
    return data.reduce((sum, current) => sum + current) / data.length;
  }

  // Partially Generated By AI
  // Added the corner case handling for the case sum = 0.
  // The answer should not return sum/2.
  /**
   * The `median` function calculates the median value of an array of numbers.
   * @param {number[]} data - An array of numbers
   * @returns The median value of the given data.
   */
  median(data: number[]): number {
    if (!data || !data.length) return NaN;
    const sortedData = data.sort((a, b) => a - b); // Sort in ascending order

    if (sortedData.length % 2 === 0) {
      const middle1 = sortedData[sortedData.length / 2 - 1];
      const middle2 = sortedData[sortedData.length / 2];
      return (middle1 + middle2) / 2;
    }

    return sortedData[Math.floor(sortedData.length / 2)];
  }

  // Calculate the mode.
  /**
   * The `mode` function takes an array of any type of data and returns a record object that represents
   * the mode (most frequently occurring value) of each unique value in the array.
   * @param {any[]} data - The `data` parameter is an array of any type of values.
   * @returns an object of type `Record<any, number>`.
   */
  mode(data: any[]): Record<any, number> {
    const ans: Record<any, number> = {};
    if (!data || !data.length) {
      return ans;
    }
    data.forEach((value) => {
      if (!ans[value]) {
        ans[value] = 0;
      }
      ans[value] = ans[value] + 1;
    });
    return ans;
  }

  // Calculate the variance.
  /**
   * The variance function calculates the variance of a given array of numbers.
   * @param {number[]} data - The `data` parameter is an array of numbers.
   * @returns the variance of the given data as a number.
   */
  variance(data: number[]): number {
    if (!data || data.length < 2) return NaN;

    const mean = this.mean(data);
    const squaredDifferencesSum = data.reduce((sum, value) => {
      const difference = value - mean;
      return sum + difference * difference;
    }, 0);

    return squaredDifferencesSum / (data.length - 1);
  }

  // Calculate the standard deviation.
  // AI Generated Code
  /**
   * The function calculates the standard deviation of a given array of numbers.
   * @param {number[]} data - The `data` parameter is an array of numbers.
   * @returns The standard deviation of the given data.
   */
  standardDeviation(data: number[]): number {
    if (!data || !data.length) return NaN;
    return Math.sqrt(this.variance(data));
  }
}
